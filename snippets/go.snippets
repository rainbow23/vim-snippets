snippet v "shorthand variable declaration"
	${1} := ${2}
	${0}

snippet vr "variable initialization"
	var ${1:t} ${0:string}

snippet var "variable declaration"
	var ${1} ${2} = ${3}

snippet vars "variables declaration"
	var (
		${1} ${2} = ${3}
	)
	${0}

snippet time "time.Sleep"
	time.Sleep(${1:int} * time.Second)
	${0}

snippet clo "close( chanel)"
	close(${1:chan})
	${0}
snippet app "append"
	append(${1:slice}, ${0:value})

snippet bo "bool"
	bool ${0}

snippet by "byte"
	byte ${0}

snippet bre "break"
	break ${0}

snippet cha "channel"
	chan ${0:int}

snippet cas "case"
	case ${1:value}:
		${0:${VISUAL}}

snippet con "const"
	const ${1:NAME} = ${0:0}

snippet cons "constants with iota"
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)

snippet cont "continue"
	continue
	${0}

snippet def "defer"
	defer ${1:func}()
    ${0}

snippet def "defer recover"
	defer func() {
		if err := recover(); err != nil {
			${0:${VISUAL}}
		}
	}()

snippet in "int "
	int ${0}

snippet imp "import"
	import (
		"${1:package}"
	)
	${0}

snippet inte "interface"
	interface{}

snippet inter "full interface "
	interface ${1:name} {
		${2:/* methods */}
	}

snippet if "if condition"
	if ${1:/* condition */} {
		${2:${VISUAL}}
	}


snippet ifelse "if else condition"
	if ${1:/* condition */} {
		${2:${VISUAL}}
	} else {
		${0}
	}

snippet els "else"
	else {
		${0:${VISUAL}}
	}

snippet if "if error not nil, return err"
	if err != nil {
		return err
	}
	${0}

snippet fal "false"
	false ${0}

snippet ft "fallthrough"
	fallthrough ${0}

snippet flo "float32"
	float32 ${0}

snippet flo "float64"
	float64 ${0}

snippet for "for loop simple"
	for {
		${1:${VISUAL}}
	}
	${0}

snippet for "for loop"
	for ${2}{
		${1:${VISUAL}}
	}
	${0}

snippet fori "for int loop"
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
		${0:${VISUAL}}
	}
	${0}

snippet forr "for range loop"
	for ${1:e} := range ${2:collection} {
		${0:${VISUAL}}
	}
	${0}

snippet fun "function"
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}
	${0}

snippet func "function lambda"
	func () {
		${1}
	}(${2})
	${0}

snippet func "function no return"
	func ${1:funcName}(${3} ${2:type}) {
		${4}
	}
	${0}

snippet func "function receiver"
	func (${2:receiver} ${1:type}) ${3:funcName}(${5} ${4:type}) {
		${6}
	}
	${0}

snippet func "http handler function on reciever"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
		${0:${VISUAL}}
	}
	${0}

snippet lo "log printf"
	log.Printf("%${1:s}", ${2:var})
	${0}

snippet lo "log println"
	log.Println("${1}")
	${0}

snippet ma "make"
	make(${1:[]string}, ${0:0})
	${0}

snippet ma "map"
	map[${1:string}]${0:int}
	${0}

snippet main "func main()"
	func main() {
		${1}
	}

snippet ne "new"
	new(${0:type})

snippet pa "package"
	package ${1:main}

snippet pn "panic"
	panic("${0:msg}")

snippet pf "fmt.Printf()"
	fmt.Printf("%${1:s}\n", ${2:var})
	${0}

snippet pl "fmt.Println()"
	fmt.Println("${1:s}")
	${0}

snippet ra "range"
	range ${0}

snippet re "return"
	return ${0}

snippet re "result"
	result

snippet sel "select { case default }"
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	default:
		${0}
	}

snippet st "string"
	string ${0}

snippet st "struct"
	struct ${1:name} {
		${2:/* data */}
	}
	${0}

snippet sw "switch"
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}

snippet fm "fmt.Sprintf"
	fmt.Sprintf("%${1:s}", ${2:var})
	${0}

snippet spr "fmt.Sprintf"
	fmt.Sprintf("%${1:s}", ${2:var})
	${0}

snippet tr "true"
	true ${0}

snippet go "goroutine named function"
	go ${1:funcName}(${2})
    ${0}

snippet go "goroutine anonymous function"
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${4})
	${0}
snippet test "test function"
	func Test${1:name}(t *testing.T) {
		${0:${VISUAL}}
	}
	${0}

snippet bench "benchmark function"
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}

snippet str "struct"
	type ${1:name} struct {
		${2:attrName} ${3:attrType}
	}
	${0}

snippet if "if key in a map"
	if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
		${4:/* code */}
	}
	${0}


snippet var "Grouped globals with anonymous struct"
	var ${1:var} = struct{
		${2:name} ${3:type}
	}{
		$2: ${4:value},
	}
	${0}


snippet ja "Marshalable json alias"
	type ${1:parentType}Alias $1

	func (p *$1) MarshalJSON() ([]byte, error) {
		return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
	}

snippet err "Error handling with errors.Wrap"
	if ${1}err != nil {
		return errors.Wrap(err, "${2}")
	}
